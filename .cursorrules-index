# Afterlife Project - Cursor Rules Index

## Overview
This project contains comprehensive Cursor rules to ensure consistent, high-quality development of the Afterlife Flutter application. The rules are organized by directory structure to provide focused guidance for each area of the codebase.

## Rule Files Structure

### ðŸ“ Master Rules
- **`.cursorrules`** - Main project rules covering architecture, AI integration, and general patterns
- **`.cursorrules-index`** - This file, explaining the rule system organization

### ðŸ“ Directory-Specific Rules
- **`.cursorrules-core`** - Core infrastructure (/lib/core)
- **`.cursorrules-features`** - Feature implementations (/lib/features) 
- **`.cursorrules-l10n`** - Internationalization (/lib/l10n)
- **`.cursorrules-main`** - Application entry point (main.dart)

## Usage Guide

### For New Development
1. **Start with `.cursorrules`** - Understand overall architecture and patterns
2. **Check directory rules** - Reference specific rules for the area you're working in
3. **Follow naming conventions** - Use established patterns for consistency
4. **Implement error handling** - Follow established error patterns
5. **Add tests** - Use testing patterns from relevant rule files

### For Code Review
1. **Verify architecture compliance** - Check against core patterns
2. **Validate feature structure** - Ensure proper organization
3. **Check internationalization** - Verify i18n compliance for user-facing text
4. **Review AI integration** - Confirm proper use of HybridChatService
5. **Assess performance** - Look for optimization opportunities

### For Refactoring
1. **Reference existing patterns** - Use established conventions
2. **Update consistently** - Apply changes across all relevant files
3. **Test thoroughly** - Follow testing guidelines for each area
4. **Maintain compatibility** - Preserve API contracts and data formats

## Rule Categories

### ðŸ—ï¸ Architecture Rules (.cursorrules)
- **State Management**: Provider patterns and lifecycle
- **Service Architecture**: Singleton services and dependency injection
- **AI Integration**: Hybrid chat service and model management
- **File Organization**: Directory structure and naming conventions

### ðŸ”§ Core Infrastructure (.cursorrules-core)
- **Services**: Core services (AI, LLM, configuration)
- **Utilities**: Helper functions and optimization
- **Widgets**: Reusable UI components
- **Theming**: App-wide styling and visual design

### ðŸŽ¯ Feature Development (.cursorrules-features)
- **Models**: Data structures and serialization
- **Providers**: Feature-specific state management
- **Screens**: UI implementation and navigation
- **Chat System**: Messaging and AI interaction
- **File Processing**: Document handling and parsing

### ðŸŒ Internationalization (.cursorrules-l10n)
- **Translation Management**: Multi-language support
- **Font Handling**: Cyrillic and complex script support
- **Cultural Adaptation**: Locale-specific considerations
- **AI Localization**: Multi-language AI interactions

### ðŸš€ Application Entry (.cursorrules-main)
- **Initialization**: App startup and service loading
- **Provider Configuration**: Global state setup
- **Error Handling**: Global error management
- **Performance**: App-level optimizations

## Key Patterns Summary

### AI Integration
```dart
// Use HybridChatService for all AI interactions
final response = await HybridChatService.sendMessageToCharacter(
  characterId: characterId,
  message: message,
  systemPrompt: character.systemPrompt,
  chatHistory: chatHistory,
  model: character.model,
  localPrompt: character.localPrompt,
);
```

### State Management
```dart
// Standard provider pattern
class ExampleProvider with ChangeNotifier {
  bool _isLoading = false;
  bool get isLoading => _isLoading;
  
  Future<void> performAction() async {
    _isLoading = true;
    notifyListeners();
    try {
      // Perform operation
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }
}
```

### Internationalization
```dart
// Always use localization for user-facing text
Text(AppLocalizations.of(context).buttonLabel)

// Support Cyrillic languages
style: UkrainianFontUtils.latoWithUkrainianSupport(
  text: text,
  fontSize: 16,
)
```

### Error Handling
```dart
try {
  final result = await someOperation();
  if (mounted) setState(() { /* update UI */ });
} catch (e) {
  if (kDebugMode) print('Error: $e');
  if (mounted) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text('User-friendly message')),
    );
  }
}
```

## Development Workflow

### 1. Planning Phase
- Review relevant rule files for the feature area
- Understand existing patterns and conventions
- Plan integration points with core services
- Consider internationalization requirements

### 2. Implementation Phase
- Follow directory-specific rules
- Use established patterns for consistency
- Implement proper error handling
- Add comprehensive logging

### 3. Testing Phase
- Write tests following testing patterns
- Verify internationalization compliance
- Test AI service integration
- Validate performance characteristics

### 4. Review Phase
- Check adherence to architectural patterns
- Verify proper resource disposal
- Validate error handling implementation
- Ensure accessibility compliance

## Common Development Scenarios

### Adding a New Feature
1. Create feature directory under `/lib/features/`
2. Follow `.cursorrules-features` for structure
3. Implement models, providers, screens, and services
4. Add internationalization strings following `.cursorrules-l10n`
5. Integrate with core services per `.cursorrules-core`

### Adding AI Functionality
1. Use `HybridChatService` for all AI interactions
2. Support both local and cloud models
3. Implement proper prompt engineering
4. Add language-specific instructions
5. Handle errors gracefully with fallbacks

### Adding New Language Support
1. Create translation file following `.cursorrules-l10n` naming
2. Implement all required methods from base class
3. Add font support if needed (Cyrillic, etc.)
4. Test UI layout with new language
5. Update supported locales list

### Optimizing Performance
1. Use `RepaintBoundary` for expensive widgets
2. Implement lazy loading for data
3. Cache frequently accessed information
4. Optimize image loading and storage
5. Monitor memory usage and disposal

## Quality Checklist

### Before Committing
- [ ] Follows established architecture patterns
- [ ] Implements proper error handling
- [ ] Uses internationalization for user text
- [ ] Includes appropriate tests
- [ ] Follows naming conventions
- [ ] Properly disposes of resources
- [ ] Handles AI integration correctly
- [ ] Supports accessibility requirements

### Before Release
- [ ] All features work with local and cloud AI
- [ ] All languages render correctly
- [ ] Performance meets standards
- [ ] Error scenarios handled gracefully
- [ ] Security considerations addressed
- [ ] Documentation updated
- [ ] Platform compatibility verified

## Maintenance Guidelines

### Regular Updates
- Review and update rule files as patterns evolve
- Add new patterns discovered during development
- Remove obsolete or deprecated patterns
- Update examples with current best practices

### Team Onboarding
- Start new developers with `.cursorrules` overview
- Review directory-specific rules for their work area
- Provide examples from existing codebase
- Pair program to reinforce patterns

### Code Quality Monitoring
- Regular architecture reviews against rule compliance
- Automated checks for common patterns
- Performance monitoring and optimization
- User experience testing across languages and platforms

## Contributing to Rules

### Proposing Changes
1. Identify area for improvement
2. Research current best practices
3. Propose specific changes with examples
4. Test changes in real development scenarios
5. Update documentation and examples

### Rule Evolution
- Rules should evolve with the codebase
- Document breaking changes clearly
- Provide migration guides when needed
- Maintain backward compatibility when possible

---

These rules ensure consistent, maintainable, and high-quality development of the Afterlife application. They should be consulted regularly and updated as the project evolves. 